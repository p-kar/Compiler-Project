/*
* @Author:    Pratyush Kar (2013A7PS029P),
*             Ayush Kataria (2013A7PS028P)
* @Email:     f2013029@pilani.bits-pilani.ac.in,
*             f2013028@pilani.bits-pilani.ac.in
* @Gp Number: 52
* @File Name: final.c
* @Date:      2016-04-21 01:54:45
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "parserUtils.h"
#include "parser.h"
#include "AST.h"
#include "typeChecker.h"
#include "semanticAnalyzer.h"
#include "codeGen.h"

int main(int argc, char const *argv[])
{
    char grammar_filename[] = "./Grammar/final_grammar.txt";
    char ast_rules_filename[] = "./Grammar/astrules.txt";
    printf("LEVEL 4: Symbol Table/AST/Semantic Ananlyzer/Type Checker/Code Gen modules work.\n");
    printf("\nPress option for the defined task:\n");
    printf("1. For printing the token list (on the console) generated by the lexer.\n");
    printf("2. For parsing to verify the syntactic correctness of the input source code and to display the parse tree.\n");
    printf("3. For printing the AST in depth first order in appropriate format.\n");
    printf("4. For displaying the amount of allocated memory and number of nodes in each of parse tree and AST.\n");
    printf("5. For printing the symbol table.\n");
    printf("6. For compiling to verify the syntactic and semantic correctness of the input source code.\n");
    printf("7. For producing the assembly code.\n");
    printf("Option: ");
    int option;
    scanf("%d", &option);
    if(option > 7)
    {
        fprintf(stderr, "Incorrect option entered.\n");
        return 1;
    }
    if(option != 7 && argc < 2)
    {
        fprintf(stderr, "USAGE: %s <testcase filename>\n", argv[0]);
        return 1;
    }
    if(option == 7 && argc < 3)
    {
        fprintf(stderr, "USAGE: %s <testcase filename> <ASM filename>\n", argv[0]);
        return 1;
    }
    const char* src_filename = argv[1];
    grammar rulelist = getRuleList(grammar_filename);
    table T = initialiseParserTable();
    createParseTable(rulelist, T);
    ASTRuleNode** ast_rule_list = readASTRuleList(ast_rules_filename);
    parseTree PT = NULL;
    ASTNode* AT = NULL;
    switch(option)
    {
        case 1:
            printTokenList(src_filename);
            break;
        case 2:
            PT = parseInputSourceCode(src_filename, rulelist, T);
            displayParseTreeSTDOUT(PT);
            break;
        case 3:
            PT = parseInputSourceCode(src_filename, rulelist, T);
            if(PARSING_ERROR_FLAG)
                return 0;
            AT = createASTfromPT(PT, ast_rule_list);
            displayASTSTDOUT(AT);
            break;
        case 4:
            PT = parseInputSourceCode(src_filename, rulelist, T);
            if(PARSING_ERROR_FLAG)
                return 0;
            AT = createASTfromPT(PT, ast_rule_list);
            int ptsize = getPTSize(PT);
            int astsize = getASTSize(AT);
            printf("Parse Tree:\tNumber of Nodes = %d\tAllocated Memory = %d Bytes\n", getPTNodeCount(PT), ptsize);
            printf("AST Tree:\tNumber of Nodes = %d\tAllocated Memory = %d Bytes\n", getASTNodeCount(AT), astsize);
            printf("Compression Percentage = %.2lf%c\n", (double)(ptsize - astsize) * 100.0/(double) ptsize, '%');
            break;
        case 5:
            PT = parseInputSourceCode(src_filename, rulelist, T);
            if(PARSING_ERROR_FLAG)
                return 0;
            AT = createASTfromPT(PT, ast_rule_list);
            AT = makeASTSymbolTableLinks(AT);
            if(AT != NULL)
                displaySymbolTable(AT->global_table);
            else
                printf("%sCannot print symbol table. AST is NULL.%s\n", KRED, KNRM);
            break;
        case 6:
            PT = parseInputSourceCode(src_filename, rulelist, T);
            if(PARSING_ERROR_FLAG)
                return 0;
            AT = createASTfromPT(PT, ast_rule_list);
            AT = makeASTSymbolTableLinks(AT);
            runTypeCheckerAST(AT);
            if(TYPECHECKER_ERROR)
                printf("%sInput source code has type errors.%s\n", KRED, KNRM);
            else
                printf("%sInput source code does not have type errors.%s\n", KGRN, KNRM);
            runSemanticAnalyzer(AT);
            if(SEMANTIC_ERROR)
                printf("%sInput source code has semantic errors.%s\n", KRED, KNRM);
            else
                printf("%sInput source code does not have semantic errors.%s\n", KGRN, KNRM);
            break;
        case 7:
            PT = parseInputSourceCode(src_filename, rulelist, T);
            if(PARSING_ERROR_FLAG)
                return 0;
            AT = createASTfromPT(PT, ast_rule_list);
            AT = makeASTSymbolTableLinks(AT);
            if(TYPECHECKER_ERROR)
                printf("%sInput source code has type errors.%s\n", KRED, KNRM);
            else
                printf("%sInput source code does not have type errors.%s\n", KGRN, KNRM);
            runSemanticAnalyzer(AT);
            if(SEMANTIC_ERROR)
                printf("%sInput source code has semantic errors.%s\n", KRED, KNRM);
            else
                printf("%sInput source code does not have semantic errors.%s\n", KGRN, KNRM);
            if(TYPECHECKER_ERROR || SEMANTIC_ERROR)
            {
                printf("%sSemantic and/or type checking errors found hence code generation not done.%s\n", KRED, KNRM);
                return 0;
            }
            generateCode(AT, argv[2]);
            break;
    }
    return 0;
}